排序概述
[冒泡排序]  
从右向左开始比较，根据结果排序。让最大的数字置于左边
对于冒泡排序，总的比较次数一直为n²/2,与数值最开始排列方式无关
[选择排序]  
与线性搜索配合的算法，“从待排序的数据中寻找最小值，如何与序列最左边的数字进行交换”
每一次操作的实质都是寻找到最小值，然后扔到前面去。在前面自然而然，会按最小值排好
次数同样是n²/2
[插入排序]
“从左向右”的排序方法，本质是从右侧的“未排序区域”取出一个数据，然后插到左边的“已排序区域”中去
如果要细究的话还是比较吃运气的，如果每次拿到的数字都比左边已归为数字要小，那么效率就会大大降低
（当然，数据不多的话这种“降低”和“运气成分”可以忽略不计）
[堆排序]
利用了数据结构的“堆”进行的排序（“堆”的概述可以看前面）
在这里，我们以降序来构建堆（之前提到的堆是“子结点一定大于父结点”的升序）
我们从降序排列的堆中取出数据，就会从最大的数据开始去，将取出的数据反序输出，排序就完成了
[归并排序]
归并：把两个排好序的子序列合并成一个有序的序列
归并排序会把序列分成长度相等的两个子序列，当无法继续下分（每个序列都只有一个数据了），进行归并
归并两个子序列时，比较它们的首位数字，并且移动较小的数字到合并序列的首位
不断进行上面的步骤，直到所有数字合并为一个序列整体
归并排序的运行时间与堆序列相同
------------------------------------------------------------------------------------------|
[快速排序]
快速排序的步骤如下
1.在序列中随机选择一个值作为“基准值pivot”
2.把其它数值分为“比基准值小”和“比基准值大”两个部分
3.然后依据2，我们可以得到这样一个排序： [比基准值小]  基准值  [比基准值大]
4.然后在对前后的[]中的数据再次进行快速排序，直到完成

