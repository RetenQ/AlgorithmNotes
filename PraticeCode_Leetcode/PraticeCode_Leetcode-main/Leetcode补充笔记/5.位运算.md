# 位运算
从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算  

### 介绍
我们有的时候可以直接利用位运算，来提高代码的执行效率    
位运算的符号如下：
\& 与 当两个位都为1的时候，结果才为1
\| 或 当两个位都为0的时候，结果才是0
\^ 异或 当两个位相同的时候为0，不同的时候为1
\~ 取反，1变0，0变1
\<< 各二进制位全部左移若干位，弃掉高位，低位补0
\>> 各二进制位全部右移若干位。对于无符号数，高位补0.对于有符号数，各编译器处理方法不同，有的补符号位(算术右移)，有的补0(逻辑右移)   

### 运算符与用途 
**与**  
```0&0=0  0&1=0  1&0=0  1&1=1```    

作用：
1.清零：和一个各位均是0的数值相与，即可使一个单元清零   
2.取位：取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&Y=0000 1110）即可得到X的指定位(实质上就是利用了清零的特性，消去了不需要的位)  
3.判断奇偶：用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数，因为末位是0的是偶数，末位为1的是奇数   

**或**  
```0|0=0  0|1=1  1|0=1  1|1=1```    
特别提醒：
1.对于3|5即 0000 0011| 0000 0101 = 0000 0111，因此，3|5的值是7  
2.负数按补码形式参加按位或运算  

作用：  
1.设置1：和"与"运算的清零作用差不多，比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到 

**异或**    
```0^0=0  0^1=1  1^0=1  1^1=0```    
参与运算的两个对象，如果两个相应位相同为0，相异为1  

性质：  
1、交换律   
2、结合律 (a^b)^c == a^(b^c)    
3、对于任何数x，都有 x^x=0，x^0=x   
4、自反性: a^b^b=a^0=a;     

作用：  
1.翻转指定位：比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到     
2.与0异或，值不会改变:例如：1010 1110 ^ 0000 0000 = 1010 1110
3.利用代码交换两个数:   
```
void Swap(int a,int b){
    if(a !=b){
        a ^= b ;
        b ^= a ; 
        a ^= b ;
    }
}
``` 

**取反**    
```~1=0 ~0=1```     
总结：对一个二进制数按位取反，将0变1，1变0。

作用：
1.使一个数的最低位为零：使a的最低位为0，可以表示为：a & ~1。~1的值为 1111 1111 1111 1110，再按"与"运算，最低位一定为0。因为" ~"运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高     

**左移与右移**  
左移运算符（<<）
定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000 

若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2    

右移运算符（>>）
定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。
例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。

操作数每右移一位，相当于该数除以2。 

### 复合赋值运算符
使用方法和说明+=，-=类似：
直接看表：
```
&=        例：a&=b    相当于     a=a&b

|=        例：a|=b    相当于     a=a|b

>>=      例：a>>=b   相当于     a=a>>b

<<=      例：a<<=b     相当于      a=a<<b

^=        例：a^=b    相当于   a=a^b
``` 

不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算  
>以"与运算"为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行"与运算"，右端对齐后，左边不足的位依下面三种情况补足:
> 1）如果整型数据为正数，左边补16个0。
>2）如果整型数据为负数，左边补16个1。
>3）如果整形数据为无符号数，左边也补16个0

### 操作
1.利用x^1 = ~x ，可以将一个数的位级表示翻转   
2.利用x^x = 0 ，可以将三个数中重复的两个数去除    
3.利用x&0=0以及x&1=x。可以实现掩码操作    
一个数num和mask：00111100进行位的与操作，只保留num中的，与mask的1部分对应的数   
4.利用x|0 = x 以及 x|1 = 1，可以实现设置操作    
一个数num与mask:00111100 进行位的或操作，可以把num中与mask中的1部分对应的数的位，全部设置为1
5.利用n&(n-1)可以去除n的位级中，最低(最后面)的那个1 
6.n&(-n)可以得到n的位级中最低的那一位1   
7.n-(n&(-n)) 可以去除 n 的位级表示中最低的那一位 1，和 n&(n-1) 效果一样 
8.\\>\\>算术右移，相对于除以2n  
9.\\>\\>\\>是无符号右移，会在左边自动补0    
10.<<是算术左移，相对于乘以2n
11.
要获取 111111111，将 0 取反即可，~0。   
要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1<<(i-1) 。例如 1<<4 得到只有第 5 位为 1 的 mask ：00010000。  
要得到 1 到 i 位为 1 的 mask，(1<<i)-1 即可，例如将 (1<<4)-1 = 00010000-1 = 00001111。  
要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1<<i)-1) 

