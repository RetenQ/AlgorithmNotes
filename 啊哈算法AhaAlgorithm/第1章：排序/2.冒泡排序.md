#冒泡排序

核心思想在于“每次比较两个相邻的元素，如果它们顺序错误就把它们交换过来”
比如，我们想要进行**从大到小**的排序，则把小的数字往**后**靠  

比如有五个数字12 35 99 18 76 ，我们试图将它们从大到小排序
1.我们首先比较第一12和第二35，显然35大。依据核心思想，替换二者。那么现在五个数的顺序就是： 35 **12** 99 18 76 
2.接着我们去比较现在的第二位12和第三位99，显然12又是更小的那个数，现在顺序变为35 99 **12**  18 76 
3.重复上面的步骤直到比较完最后一位数字，最后我们得到的顺序是35 99 18 76 **12**，我们可以发现，“一趟”下来之后，我们将最小的数字排序到了最后面
4.重复上述步骤，依次找到“第二小的”，“第三小的”...最终完成我们的排序。冒泡排序，每一趟只可以确定将**一个数**归位

>总结：有n个数字进行排序，只需要将n-1个数归位，进行n-1趟操作

##代码示例
```C
    int a[100] ; 
    int i,j,t,n ; 
    //输入一个数n，表示下面有n个数字
    scanf("%d",&n);

    for(i = 1 ; i <= n ; i++){
        //循环读入n个数到我们的数组a中
        scanf("%d",&a[i]);
        //实际上，n是要小于101的，否则装不下，这个反正可以再改
    }

    //！下面就是冒泡排序的核心算法了
    for(i = 1 ; i <= n-1 ; i++){
        for(j =1 ; j <= n-1 ; j++){
            //从第一位一直直到最后一位“还没归位”的数字
            if(a[j] < a[j+1]){
                t = a[j];
                a[j] = a [j+1];
                a[j+1] = t ;
                //比较大小并交换，交换过程中t只是一个工具罢了
            }
        }
    }
    //这样就完成了冒泡排序了

    //下面输出试试
    for(i = 1 ; i<= n ;i++){
        printf("%d",a[i]);
        }
```