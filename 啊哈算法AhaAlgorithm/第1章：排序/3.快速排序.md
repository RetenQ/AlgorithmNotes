#快速排序
快速排序的核心是**基准数**，基准数理论上是可以随机的一个数，这里我们每次都选择第一个/最左边的数作为基准数

我们可以认为，快速排序的过程，就是不断选择基准数排序的过程。我们大致可以这么描述它的步骤：
【比如我们排序 6 1 2 7 9 3 4 5 10 8 】
1.选择一个数作为基准数，我们这里就是6
2.派出两个变量去“搜索”比3大的数，和比小的数。这里我们选i与j
3.i和j从两头开始搜索，i从最左边（第0位），而j从最右边(最后一位)
4.i从左向右搜索，j从右向左进行搜索。当二者都成功找到后，交换这两个变量指向的数值
5.比如，第一次交换后，我们得到 
    【6 1 2 **7** 9 3 4 **5** 10 8】
    【6 1 2 **5** 9 3 4 **7** 10 8】
6.继续让i向右搜索而j向左搜索，这里我们可以再次得到以此9和4的交换，得到
【6 1 2 5 **4**  3  **9** 7 10 8】
这时候我们的两个用来探索的变量已经即将“遇上”，如果此时我们也找不到其它的相互交换的数值，则算结束了一轮搜索
7.把它们相遇的位置和最开始的基准数交换，这里就是3和6互换
8.此时的序列变成 **3** 1 2 5 4 **6** 9 7 10 8 
9.此时我们可以发现：这个序列变成了一个以6为分界点的序列，左边都比它小而右边都比它大。这正是我们的目的。
10.对6的左边和右边一直重复2-9的过程，直到所有数字完成排序

##代码示例
```C
int a[101],n ; //需要在子函数里面使用的全局变量

void quicksort(int left , int right){
    int i,j,t,temp ; 
    if(left>right)  return ;

    temp = a[left]; //temp中存储我们的基准数
    i = left ; 
    j = right ; 
    while(i!=j){
        //记住顺序：我们需要先“从右往左”找
        while(a[j] >= temp && i<j)  j-- ;

        //再“从左往右”找
        while(a[i] <= temp && i<j)  i++ ;

        //交换两个数再数组中的位置
        if(i<j){
            //当二者“还没有相遇”
            t = a[i] ; 
            a[i]=a[j];
            a[j] = t ;
        }
    }

    //将基准数归位
    a[left] = a[i] ;
    a[i] = temp ;

    quicksort(left,i-1);   //继续处理左边的，这里是一个递归
    quicksort(i+1,right) ; //同理，继续递归处理右边
    return

}

int main(){
    int i , j ;
    scanf("%d",&n) ;   //读入数据
    for(i = 1 ; i<= n ;i++){
        scanf("%d",&a[i]);
    }

    quicksort(1,n);

    //输出结果
    for(i = 1 ; i <= n ;i++){
        printf("%d",a[i]);
    }

    getchar();getchar();
    return 0 ;
}

```