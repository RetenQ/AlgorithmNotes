# 深度优先搜索 Depth First Search DFS  
深度优先是比较基础的一种方法，还有一种是它的兄弟广度优先  
**深度优先**顾名思义：先深入搜索到一种情况的"底部"（原谅我用了这么抽象的词），然后再返回搜索其它情况

### 例题
我们依旧举例说明，比如我们现在想要在A,B,C三个箱子中放入1,2,3三张牌，想知道一个有多少种情况

### 循环举穷
首先我们一步步尝试每一次，每一个箱子中的放牌情况  
我们约定，对于每个箱子，我们都优先放入1，然后是2，最后是3  
当然，如果手上一张牌都没有，也就说明某种情况被列举完了  
我们用一个数组a代表箱子，step代表第step个箱子，而i代表牌  
我们利用下面这个循环来进行举穷  
```C
    for(i = 1;i<=n:i++ ){
        a[step] = i ;
    }
```
另外，**一张牌只能用一次**，因此我们还要加入一个标记数组book  
我们约定： book[i]= 0 代表牌还在手上，=1代表用掉了  

所以，我们能把代码更新为：  
```C
    for(i = 1;i<=n:i++ ){
        if(book[i] == 0 ){
            a[step] = i ; //将i号扑克牌放入第step个箱子中
            book[i] = i ; //将book[i] 设为1，代表我们的i号扑克已经不在手上了
        }
    }
```

### 方法与递归
我们观察整体的解法已经上述的举穷，不难发现：我们想要的搜索，实质上就是不断使用上面的方法  
所以，我们处理每个盒子的方法都是一样的，我们之间把上述代码变成方法 

```C
    void dfs(int step){
        //step是箱子处理第step个箱子

        for(i = 1;i<=n:i++ ){
            if(book[i] == 0 ){
            a[step] = i ; //将i号扑克牌放入第step个箱子中
            book[i] = i ; //将book[i] 设为1，代表我们的i号扑克已经不在手上了
        }
    }

        return ; 
    }
```  

我们不断按顺序处理下去，每次都在方法中调用方法自身并把参数加一，我们把这样的做法叫**递归** 
另外，每一个箱子尝试之后，记得收回牌  
>事实上，开始“收牌”就意味着某一次的情况已经被举完了

```C
    void dfs(int step){
        //step是箱子处理第step个箱子

        for(i = 1;i<=n:i++ ){
            if(book[i] == 0 ){
            a[step] = i ; //将i号扑克牌放入第step个箱子中
            book[i] = i ; //将book[i] 设为1，代表我们的i号扑克已经不在手上了
            dfs(step+1);  //递归
            book[i] = 0 ; //收牌
        }
    }

        return ; 
    }
```

### 收尾
那么我们的搜索什么时候是个头呢，也就是我们搜到第n+1个盒子的时候  
（因为卡牌数量和盒子是对应的，循环中n代表有几张牌） 

所以，处理到第n+1个盒子时，我们就打印出放法，然后return  
>P.S 不return就死循环了 

完整的方法代码如下：   
```C
    void dfs(int step){
        if(step == n+1){
            //放好牌的情况
            for(i=1;i<=n;i++)
                printf("%d",a[i]);
            printf("\n");

            return ; 
        }


        //step是箱子处理第step个箱子

        for(i = 1;i<=n:i++ ){
            if(book[i] == 0 ){
            a[step] = i ; //将i号扑克牌放入第step个箱子中
            book[i] = i ; //将book[i] 设为1，代表我们的i号扑克已经不在手上了
            dfs(step+1);  //递归
            book[i] = 0 ; //收牌
            }
        }
        return ; 

    }
```

### 完整代码

```C
    #incluide <stdio.h>

    int a[10],book[10],n ; 

        void dfs(int step){
        if(step == n+1){
            //放好牌的情况
            for(i=1;i<=n;i++)
                printf("%d",a[i]);
            printf("\n");

            return ; 
        }


        //step是箱子处理第step个箱子

        for(i = 1;i<=n:i++ ){
            if(book[i] == 0 ){
            a[step] = i ; //将i号扑克牌放入第step个箱子中
            book[i] = i ; //将book[i] 设为1，代表我们的i号扑克已经不在手上了
            dfs(step+1);  //递归
            book[i] = 0 ; //收牌
            }
        }
        return ; 

    }

    int main(){
        scanf("%d",&n);
        dfs(1);
        getchar();getchar();
        return 0 ;
    }
```  

### 小结  
理解深度优先搜索的关键在于解决**当下该如何做**以及**下一步如何做**的内容  
而“下一步如何做”往往可以利用循环或递归解决  
我们可以把深度优先算法的模型概括为：  
```C
    void dfs(int step){
        判断边界
        尝试每一种可能 for(i=1;i<=n;i++)
        {
            继续下一步做啥 dfs(step+1) ; 
        }
        返回 
    }
```

本篇MD记录了深度优先算法最基本的运用，下一篇我们会尝试在更实际的地方运用它：地图搜索  